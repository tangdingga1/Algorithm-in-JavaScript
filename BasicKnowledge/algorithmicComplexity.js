
/* 算法复杂度概念 */

/**
* Q：为什么需要算法复杂度分析
* A：因为通过直接跑程序来获得复杂度所受的其他影响因素过大（程序语言运行速度， 硬件运行条件）
*    我们需要一个不用具体的测试数据来测试，就可以粗略地估计算法的方法。即空间、时间复杂度分析法
*/


/* 大O表示法 */

/**
* Q：大O表示法是什么
* A：粗略表示复杂度的方法,不考虑其他因素，把一次程序运行时间粗略的表示为 **1单位**,这个单位学术上用O来表示，成为大O表示法
*    O是一个抽象的概念表示单位的程序运行时间
*/

//比如，赋值操作，一个单位时间
let something = 1111;
let something_2 = 2222;

//加减运算
let addSomething = something + something_2;


//多个单位时间就是多项单单位运算总和
() => {
    let getSum = 0; //单位1的赋值操作

    //不用担心这个未声明的n，函数没有运行它不会报错
    for(let i = 0; i <= n; i++) {
        getSum += i; //即使i不停的增大，每一次赋值操作运行时间仍然为1个单位，和数据的大小无关!

        for(let j = 0; j <= n; j++) {
            getSum = getSum + i * j; //这里运行时间仍然为1个单位
        }
    }
}
/** 假设这个函数总的运行时间为T(n), 其中T表示time时间，n则为数据规模的大小，因为上面我们的循环都是<=n
*  **28行** 我们进行时间为1单位的赋值运算，定义了一个累加器，此处记为1
*
*  **31行** 我们进行了一个for循环，for循环当中，存在1个赋值操作，我们定义i的初始值为0，此处记时间为1单位
*           然后我们在n次的循环当中，我们进行了n次的i++的操作(单位1的赋值操作)，此处记时间为n单位
*
*  **32行** 在n次的for循环中，我们队getSum进行了一个累加，因此此处时间计为n单位
*
*  我们可以看到在31和32一次for循环中，我们花费了2n + 1个单位的复杂度
*  
*  **35行** 注意！此处的for循环是在外层for循环执行基础上执行的。所以时间复杂度会建立在n上
*           赋值j，执行了n次，n次的j++累加，执行了n*n为n²次的操作
*  
*  **36行** 同样此处的赋值操作进行了n²个单位时间
*  
*  此处的for循环，进行了2n² + n 个单位时间的操作
*
*  因此此处函数总共消耗了2n² + 3n + 2 的时间单位
*  即T(n) = O(2n² + 3n + 2)，O是一个抽象的意义，它代表每个程序单词运行的时间
*  
*  实际上在考量算法时间复杂度的时候，随着n的无限大化，低阶的影响将会考虑不计，如上面T(n) = O(2n² + 3n + 2)，随着n的增大，3n和2的影响会越来越小
*  此时我们只会考虑最高阶的情况，即上式为T(n) = O(2n²)
*
*  这个公式就是算法时间复杂度公式  T(n) = O(f(n))
*/

/* 时间复杂度分析的几个原则 */

/**
 * 原则1.只关注执行次数最多的一段代码
 * 原则2.总复杂度等于量级最大的那段代码的复杂度
 * 原则3.嵌套代码的复杂度等于嵌套内外代码复杂度的乘积
*/

/* 常见算法分析 */

/**
 * O(1)级别，算法时间复杂度不随着n增大而增大
 * 一般来说不存在循环递归，无论多少行代码时间复杂度都为O(1)
  */
let a = 1;
let b = 2;
let c = a + b * a;


/**
 * O(logn)
*/
let i = 1;
while(i < n) {
    i *= 2;
}
/**
 * 上段代码的时间复杂度很简单就是需要知道这段程序循环了多少次，实际上，这里是在计算i的平方阶
 * 假设程序运行了x次，那么 2 ^ x = n, x = log2n
 * 实际上在算法中，我们会忽略常数项，在n无限大的时候，我们会忽略对数的常数度，不管它是以2为底还是以3为底
 * 所以此处的算法时间复杂度为 T(n) = O(logn)
  */

/**
 * O(m+n)、O(m*n),当存在多个未知数趋势数的时候，我们需要进行对应的相加相乘处理计算出来对应的算法复杂度
  */

() => {
    for(let i = 1; i < m; i++) { //运行m次
        console.log(i);
    }
    for(let j = 1; j < n; j++) { //运行n次
        console.log(j);
    }
}
//这个函数的算法复杂度为O(m+n)，因为我们无法评估出m和n哪个量级最大。如果我们可以得出m或者n量级大，对应的算法复杂度就可以谢伟O(m | n)


//算法的复杂度不会离开O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )这几个常用复杂度

